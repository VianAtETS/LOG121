@startuml AlgorithmesTri
skinparam classFontSize 16
skinparam defaultFontSize 14
skinparam noteFontSize 12

title Laboratoire #4 - Algorithmes de Tri - Diagramme de Classes

abstract class AlgorithmeTri {
  # collection: List<Integer>
  # observateur: ObservateurTri

  + AlgorithmeTri(collection: List<Integer>)
  + setObservateur(observateur: ObservateurTri): void
  + executer(): void
  # notifierEtape(description: String, indices: Map<String, Integer>): void
  # copierCollection(): List<Integer>

  ' MÉTHODE TEMPLATE
  ' executer(): void
  '   copie = copierCollection()
  '   notifierEtape("État initial", null)
  '   trierRecursif(copie, 0, copie.size() - 1)
  '   notifierEtape("Tri terminé", null)

  {abstract} # trierRecursif(liste: List<Integer>, debut: int, fin: int): void
}

class QuickSort {
  + QuickSort(collection: List<Integer>)
  # trierRecursif(liste: List<Integer>, debut: int, fin: int): void
  - partitionner(liste: List<Integer>, debut: int, fin: int): int
  - choisirPivot(debut: int, fin: int): int
  - echanger(liste: List<Integer>, i: int, j: int): void

  ' trierRecursif(liste, debut, fin):
  '   if (debut < fin) then
  '     pivotIndex = partitionner(liste, debut, fin)
  '     indices = Map("pivot", pivotIndex)
  '     notifierEtape("Partitionnement", indices)
  '     trierRecursif(liste, debut, pivotIndex - 1)
  '     trierRecursif(liste, pivotIndex + 1, fin)

  ' partitionner(liste, debut, fin): int
  '   pivotIndex = choisirPivot(debut, fin)
  '   pivot = liste[pivotIndex]
  '   echanger(liste, pivotIndex, fin)
  '   i = debut
  '   for j = debut to fin - 1
  '     if liste[j] < pivot then
  '       echanger(liste, i, j)
  '       indices = Map("i", i, "j", j)
  '       notifierEtape("Échange", indices)
  '       i++
  '   echanger(liste, i, fin)
  '   return i
}

class MergeSort {
  + MergeSort(collection: List<Integer>)
  # trierRecursif(liste: List<Integer>, debut: int, fin: int): void
  - fusionner(liste: List<Integer>, debut: int, milieu: int, fin: int): void

  ' trierRecursif(liste, debut, fin):
  '   if (debut < fin) then
  '     milieu = (debut + fin) / 2
  '     indices = Map("debut", debut, "milieu", milieu, "fin", fin)
  '     notifierEtape("Division", indices)
  '     trierRecursif(liste, debut, milieu)
  '     trierRecursif(liste, milieu + 1, fin)
  '     fusionner(liste, debut, milieu, fin)
  '     notifierEtape("Fusion", indices)

  ' fusionner(liste, debut, milieu, fin):
  '   gauche = liste[debut..milieu]
  '   droite = liste[milieu+1..fin]
  '   i = 0, j = 0, k = debut
  '   while (i < gauche.size() && j < droite.size())
  '     if (gauche[i] <= droite[j]) then
  '       liste[k] = gauche[i++]
  '     else
  '       liste[k] = droite[j++]
  '     k++
  '   copier les éléments restants de gauche et droite
}

class EtapeTri {
  - description: String
  - collectionState: List<Integer>
  - indices: Map<String, Integer>
  - timestamp: long

  + EtapeTri(description: String, collection: List<Integer>, indices: Map<String, Integer>)
  + getDescription(): String
  + getCollectionState(): List<Integer>
  + getIndices(): Map<String, Integer>
  + getTimestamp(): long
}

interface ObservateurTri {
  + notifierNouvelleEtape(etape: EtapeTri): void
  + notifierFinTri(): void
}

class GestionnaireTri {
  - algorithme: AlgorithmeTri
  - etapes: List<EtapeTri>
  - collectionInitiale: List<Integer>

  + GestionnaireTri()
  + setCollection(collection: List<Integer>): void
  + setAlgorithme(type: TypeAlgorithme): void
  + executerTri(): List<EtapeTri>
  + getEtapes(): List<EtapeTri>
  + notifierNouvelleEtape(etape: EtapeTri): void
  + notifierFinTri(): void
  - creerAlgorithme(type: TypeAlgorithme): AlgorithmeTri
}

enum TypeAlgorithme {
  QUICK_SORT
  MERGE_SORT
}

class AnimateurTri {
  - etapes: List<EtapeTri>
  - indexEtapeCourante: int
  - timeline: Timeline
  - vitesse: double
  - enPause: boolean
  - renderTri: RenderTri

  + AnimateurTri(renderTri: RenderTri)
  + setEtapes(etapes: List<EtapeTri>): void
  + setVitesse(vitesse: double): void
  + demarrer(): void
  + pause(): void
  + reprendre(): void
  + arreter(): void
  + reinitialiser(): void
  - afficherEtapeSuivante(): void
  - creerTimeline(): void
}

interface RenderTri {
  + dessiner(etape: EtapeTri): void
  + effacer(): void
}

class RenderBarres {
  - canvas: Canvas
  - gc: GraphicsContext
  - couleurNormale: Color
  - couleurComparaison: Color
  - couleurPivot: Color

  + RenderBarres(canvas: Canvas)
  + dessiner(etape: EtapeTri): void
  + effacer(): void
  - calculerDimensionsBarre(nbElements: int): double
  - calculerHauteur(valeur: int, maxValeur: int): double
  - determinerCouleur(index: int, indices: Map<String, Integer>): Color
  - dessinerBarre(x: double, y: double, largeur: double, hauteur: double, couleur: Color): void
  - dessinerValeur(valeur: int, x: double, y: double): void
}

class VueParametres {
  - stage: Stage
  - controleur: ControleurParametres
  - comboAlgorithme: ComboBox<String>
  - txtCollection: TextField
  - comboVitesse: ComboBox<String>

  + VueParametres(stage: Stage, controleur: ControleurParametres)
  + afficher(): void
  + fermer(): void
  + getAlgorithmeSelectionne(): String
  + getCollection(): String
  + getVitesse(): String
  + afficherErreur(message: String): void
  - initialiserComposants(): void
  - creerLayout(): Parent
}

class ControleurParametres {
  - gestionnaire: GestionnaireTri
  - vueParametres: VueParametres
  - controleurVisualisation: ControleurVisualisation

  + ControleurParametres(gestionnaire: GestionnaireTri)
  + setControleurVisualisation(controleur: ControleurVisualisation): void
  + afficherVue(): void
  + validerEtLancerTri(): void
  + annuler(): void
  - validerCollection(texte: String): boolean
  - parseCollection(texte: String): List<Integer>
  - convertirVitesse(vitesse: String): double
}

class VueVisualisation {
  - stage: Stage
  - controleur: ControleurVisualisation
  - canvas: Canvas
  - btnJouer: Button
  - btnPause: Button
  - btnArreter: Button
  - lblEtape: Label

  + VueVisualisation(stage: Stage, controleur: ControleurVisualisation)
  + afficher(): void
  + getCanvas(): Canvas
  + mettreAJourEtape(description: String): void
  + activerBoutonJouer(actif: boolean): void
  + activerBoutonPause(actif: boolean): void
  - initialiserComposants(): void
  - creerLayout(): Parent
}

class ControleurVisualisation {
  - gestionnaire: GestionnaireTri
  - animateur: AnimateurTri
  - vueVisualisation: VueVisualisation
  - render: RenderTri

  + ControleurVisualisation(gestionnaire: GestionnaireTri)
  + initialiser(): void
  + demarrerAnimation(etapes: List<EtapeTri>, vitesse: double): void
  + jouer(): void
  + pause(): void
  + arreter(): void
  + reinitialiser(): void
  - creerRender(canvas: Canvas): RenderTri
}

class ApplicationPrincipale {
  - gestionnaire: GestionnaireTri
  - controleurParametres: ControleurParametres
  - controleurVisualisation: ControleurVisualisation

  + start(primaryStage: Stage): void
  + main(args: String[]): void
  - initialiserControleurs(): void
}

' Relations - Patron Template
AlgorithmeTri <|-- QuickSort
AlgorithmeTri <|-- MergeSort
AlgorithmeTri ..> EtapeTri : crée >
AlgorithmeTri --> ObservateurTri : notifie >

' Relations - Gestion du tri
GestionnaireTri ..|> ObservateurTri
GestionnaireTri --> AlgorithmeTri : utilise >
GestionnaireTri --> TypeAlgorithme : utilise >
GestionnaireTri o-- EtapeTri : stocke >

' Relations - Animation
AnimateurTri --> RenderTri : utilise >
AnimateurTri o-- EtapeTri : anime >
RenderTri <|.. RenderBarres

' Relations - MVC Paramètres
ControleurParametres --> VueParametres : gère >
ControleurParametres --> GestionnaireTri : utilise >
VueParametres ..> ControleurParametres : notifie >

' Relations - MVC Visualisation
ControleurVisualisation --> VueVisualisation : gère >
ControleurVisualisation --> AnimateurTri : contrôle >
ControleurVisualisation --> GestionnaireTri : utilise >
ControleurVisualisation --> RenderBarres : crée >
VueVisualisation ..> ControleurVisualisation : notifie >
VueVisualisation *-- Canvas

' Relations - Application
ApplicationPrincipale --> GestionnaireTri : crée >
ApplicationPrincipale --> ControleurParametres : crée >
ApplicationPrincipale --> ControleurVisualisation : crée >
ControleurParametres --> ControleurVisualisation : collabore >

note left of AlgorithmeTri::executer
  **MÉTHODE TEMPLATE**
  Définit le squelette de l'algorithme.
  Les sous-classes implémentent
  trierRecursif() avec leur logique
  spécifique.
end note

note bottom of GestionnaireTri
  Implémente ObservateurTri pour
  collecter toutes les étapes du tri.
  Coordonne l'exécution des algorithmes.
end note

note bottom of AnimateurTri
  Utilise Timeline de JavaFX pour
  animer les étapes de façon fluide.
  Gère play/pause/stop.
end note

note right of RenderBarres
  Utilise Canvas et GraphicsContext
  de JavaFX pour dessiner les barres.
  Applique des couleurs selon les indices.
end note

@enduml
