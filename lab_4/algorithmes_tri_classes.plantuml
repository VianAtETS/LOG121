@startuml AlgorithmesTri
skinparam classFontSize 16
skinparam defaultFontSize 14
skinparam noteFontSize 12

title Laboratoire #4 - Algorithmes de Tri - Diagramme de Classes

abstract class TrieAlgorithme {
  # collection: List<Integer>
  # visualisateur: Visualisateur
  # etapes: List<EtapeTri>

  + TrieAlgorithme(collection: List<Integer>, visualisateur: Visualisateur)
  + trier(): List<Integer>
  # diviser(debut: int, fin: int): void
  # fusionner(debut: int, milieu: int, fin: int): void
  # estTrie(debut: int, fin: int): boolean
  # enregistrerEtape(description: String): void

  ' MÉTHODE TEMPLATE
  ' trier(): List<Integer>
  '   etapes.clear()
  '   enregistrerEtape("État initial")
  '   trierRecursif(0, collection.size() - 1)
  '   enregistrerEtape("État final - trié")
  '   return collection

  ' trierRecursif(debut: int, fin: int): void
  '   if (!estTrie(debut, fin)) then
  '     diviser(debut, fin)  // méthode abstraite
  '     fusionner(debut, milieu, fin)  // méthode abstraite
  '     enregistrerEtape("Après fusion")

  {abstract} # trierRecursif(debut: int, fin: int): void
}

class QuickSort {
  - pivot: int

  + QuickSort(collection: List<Integer>, visualisateur: Visualisateur)
  # trierRecursif(debut: int, fin: int): void
  - partitionner(debut: int, fin: int): int
  - choisirPivot(debut: int, fin: int): int

  ' trierRecursif(debut, fin):
  '   if (debut < fin) then
  '     pivotIndex = partitionner(debut, fin)
  '     enregistrerEtape("Partitionnement autour du pivot")
  '     trierRecursif(debut, pivotIndex - 1)
  '     trierRecursif(pivotIndex + 1, fin)

  ' partitionner(debut, fin): int
  '   pivot = choisirPivot(debut, fin)
  '   i = debut - 1
  '   for j = debut to fin - 1
  '     if collection[j] < pivot then
  '       i++
  '       échanger(collection[i], collection[j])
  '   échanger(collection[i + 1], collection[fin])
  '   return i + 1
}

class MergeSort {
  + MergeSort(collection: List<Integer>, visualisateur: Visualisateur)
  # trierRecursif(debut: int, fin: int): void
  - fusionnerSousCollections(debut: int, milieu: int, fin: int): void

  ' trierRecursif(debut, fin):
  '   if (debut < fin) then
  '     milieu = (debut + fin) / 2
  '     trierRecursif(debut, milieu)
  '     trierRecursif(milieu + 1, fin)
  '     fusionnerSousCollections(debut, milieu, fin)
  '     enregistrerEtape("Fusion des sous-collections")

  ' fusionnerSousCollections(debut, milieu, fin):
  '   copie1 = collection[debut..milieu]
  '   copie2 = collection[milieu+1..fin]
  '   i = 0, j = 0, k = debut
  '   while (i < copie1.size() && j < copie2.size())
  '     if (copie1[i] <= copie2[j]) then
  '       collection[k++] = copie1[i++]
  '     else
  '       collection[k++] = copie2[j++]
  '   copier les éléments restants
}

class EtapeTri {
  - description: String
  - collectionState: List<Integer>
  - timestamp: long
  - indices: Map<String, Integer>
  - elementsEnComparaison: Set<Integer>
  - elementsModifies: Set<Integer>

  + EtapeTri(description: String, collection: List<Integer>)
  + getDescription(): String
  + getCollectionState(): List<Integer>
  + getIndices(): Map<String, Integer>
  + setIndice(nom: String, valeur: int): void
  + marquerComparaison(index1: int, index2: int): void
  + marquerModification(index: int): void
  + getElementsEnComparaison(): Set<Integer>
  + getElementsModifies(): Set<Integer>
}

interface Visualisateur {
  + afficherEtape(etape: EtapeTri): void
  + demarrerAnimation(): void
  + pauserAnimation(): void
  + arreterAnimation(): void
  + setVitesseAnimation(vitesse: int): void
}

class VisualisateurGraphique {
  - canvas: Canvas
  - timeline: Timeline
  - vitesseAnimation: int
  - etapesCourantes: List<EtapeTri>
  - indexEtapeCourante: int
  - couleurs: Map<Integer, Color>

  + VisualisateurGraphique(canvas: Canvas)
  + afficherEtape(etape: EtapeTri): void
  + demarrerAnimation(): void
  + pauserAnimation(): void
  + arreterAnimation(): void
  + setVitesseAnimation(vitesse: int): void
  - dessinerBarres(collection: List<Integer>): void
  - dessinerIndices(indices: Map<String, Integer>): void
  - animerTransition(etapeActuelle: EtapeTri, etapeSuivante: EtapeTri): void
  - calculerCouleurBarre(valeur: int, index: int, etape: EtapeTri): Color
  - calculerHauteurBarre(valeur: int, maxValeur: int): double
  - calculerLargeurBarre(nbElements: int): double

  ' dessinerBarres(collection):
  '   gc = canvas.getGraphicsContext2D()
  '   gc.clearRect(0, 0, canvas.width, canvas.height)
  '   largeurBarre = calculerLargeurBarre(collection.size())
  '   maxValeur = collection.max()
  '   for i = 0 to collection.size() - 1
  '     hauteur = calculerHauteurBarre(collection[i], maxValeur)
  '     couleur = calculerCouleurBarre(collection[i], i, etapeCourante)
  '     x = i * largeurBarre
  '     y = canvas.height - hauteur
  '     gc.setFill(couleur)
  '     gc.fillRect(x, y, largeurBarre - 2, hauteur)
  '     gc.fillText(collection[i], x, canvas.height - 5)
}

class ControleurApplication {
  - visualisateur: Visualisateur
  - algorithmeActuel: TrieAlgorithme
  - collectionOriginale: List<Integer>
  - fenetreParametres: FenetreParametres
  - fenetreVisualisation: FenetreVisualisation

  + ControleurApplication()
  + demarrer(): void
  + setCollection(collection: List<Integer>): void
  + selectionnerAlgorithme(type: String): void
  + lancerTri(): void
  + pauserAnimation(): void
  + reprendreAnimation(): void
  + arreterAnimation(): void
  + reinitialiser(): void
  + afficherFenetreParametres(): void
  + afficherFenetreVisualisation(): void
  - creerAlgorithme(type: String): TrieAlgorithme
}

class FenetreParametres {
  - controleur: ControleurApplication
  - comboAlgorithme: ComboBox<String>
  - champCollection: TextField
  - comboVitesse: ComboBox<String>
  - boutonOK: Button
  - boutonAnnuler: Button
  - boutonAppliquer: Button

  + FenetreParametres(controleur: ControleurApplication)
  + afficher(): void
  + validerSaisie(): boolean
  - parseCo llection(texte: String): List<Integer>
  - gererBoutonOK(): void
  - gererBoutonAppliquer(): void
}

class FenetreVisualisation {
  - controleur: ControleurApplication
  - canvas: Canvas
  - boutonJouer: Button
  - boutonPause: Button
  - boutonArreter: Button
  - labelEtape: Label

  + FenetreVisualisation(controleur: ControleurApplication)
  + afficher(): void
  + mettreAJour(): void
  - gererControlesAnimation(): void
}

' Relations
TrieAlgorithme <|-- QuickSort
TrieAlgorithme <|-- MergeSort
TrieAlgorithme o-- EtapeTri : contient >
TrieAlgorithme --> Visualisateur : utilise >
Visualisateur <|.. VisualisateurGraphique
ControleurApplication --> TrieAlgorithme : crée et utilise >
ControleurApplication --> Visualisateur : utilise >
ControleurApplication --> FenetreParametres : gère >
ControleurApplication --> FenetreVisualisation : gère >
FenetreParametres ..> ControleurApplication : notifie >
FenetreVisualisation --> VisualisateurGraphique : contient >
VisualisateurGraphique --> EtapeTri : affiche >

note left of TrieAlgorithme::trier
  **MÉTHODE TEMPLATE**
  Définit le squelette de l'algorithme
  Les sous-classes implémentent
  les étapes spécifiques
end note

note bottom of QuickSort
  Implémente le tri rapide avec
  partitionnement autour d'un pivot
end note

note bottom of MergeSort
  Implémente le tri fusion avec
  division équitable et fusion triée
end note

note right of EtapeTri
  Capture l'état de la collection
  à chaque étape avec métadonnées
  pour la visualisation colorée
end note

note bottom of VisualisateurGraphique
  Dessine des barres colorées
  représentant les valeurs.
  Les couleurs changent selon
  l'état (comparaison, modification, trié)
end note

@enduml
